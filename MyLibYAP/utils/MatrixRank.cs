using System;

namespace MyLibYAP.utils
{
    public class Rank
    {
        private double[,] a; //Массив коэффициентов при неизвестных
        private double[] b; //Массив свободных коэффициентов
        private int n; //Количество неизвестных системы (количество уравнений)

        public Rank(double[,] a, double[] b, int n)
        {
            this.a = a;
            this.b = b;
            this.n = n;
        }

        /// <summary>
        /// Вычисление ранга основной матрицы
        /// </summary>
        /// <returns>Ранг основной матрицы</returns>
        public int Rank_a()
        {
            int i = 0, j = 0, k, l = 0;
            double r, eps = 0.00000001; // точность 10^-8

            double[,] a1 = new double[n, n];
            //временный массив для основной матрицы
            for (int p = 0; p < n; p++)
                for (int q = 0; q < n; q++)
                    a1[p, q] = a[p, q];

            while (i < n && j < n)
            {
                // Ищем максимальный элемент в j-м столбце,
                // начиная с i-й строки
                r = 0.0;
                for (k = i; k < n; ++k)
                {
                    if (Math.Abs(a1[k, j]) > r)
                    {
                        l = k;      // Запомним номер строки
                        r = Math.Abs(a1[k, j]); // и макс. эл-т
                    }
                }
                if (r <= eps)
                {
                    // Все элементы j-го столбца по абсолютной
                    // величине не превосходят eps.
                    // Обнулим столбец, начиная с i-й строки
                    for (k = i; k < n; ++k)
                    {
                        a1[k, j] = 0.0;
                    }
                    ++j;      // Увеличим индекс столбца
                    continue; // Переходим к следующей итерации
                }

                if (l != i)
                {
                    // Меняем местами i-ю и l-ю строки
                    for (k = j; k < n; ++k)
                    {
                        r = a1[i, k];
                        a1[i, k] = a1[l, k];
                        a1[l, k] = (-r); // Меняем знак строки
                    }
                }

                // Обнуляем j-й столбец, начиная со строки i+1,
                // применяя элем. преобразования второго рода
                for (k = i + 1; k < n; ++k)
                {
                    r = (-a1[k, j] / a1[i, j]);

                    // К k-й строке прибавляем i-ю, умноженную на r
                    a1[k, j] = 0.0;
                    for (l = j + 1; l < n; ++l)
                    {
                        a1[k, l] += r * a1[i, l];
                    }
                }
                ++i; ++j;   // Переходим к следующему минору
            }
            Array.Clear(a1, 0, n * n);
            return i; // Возвращаем число ненулевых строк (ранг матрицы) 
        }

        /// <summary>
        /// Вычисление ранга расширенной матрицы
        /// </summary>
        /// <returns>Ранг расширенной матрицы</returns>
        public int Rank_a2()
        {
            double[,] a1 = new double[n + 1, n + 1];
            //временный массив для расширенной матрицы
            for (int q = 0; q < n; q++)
            {
                for (int p = 0; p < n; p++)
                    a1[q, p] = a[q, p];
                a1[q, n] = b[q];
            }
            for (int d = 0; d < n; d++)
                a1[n, d] = 0;

            int i = 0, j = 0, k, l = 0;
            double r, eps = 0.00000001; // точность 10^-8

            while (i < n + 1 && j < n + 1)
            {
                // Ищем максимальный элемент в j-м столбце,
                // начиная с i-й строки
                r = 0.0;
                for (k = i; k < n + 1; ++k)
                {
                    if (Math.Abs(a1[k, j]) > r)
                    {
                        l = k;      // Запомним номер строки
                        r = Math.Abs(a1[k, j]); // и макс. эл-т
                    }
                }
                if (r <= eps)
                {
                    // Все элементы j-го столбца по абсолютной
                    // величине не превосходят eps.
                    // Обнулим столбец, начиная с i-й строки
                    for (k = i; k < n + 1; ++k)
                    {
                        a1[k, j] = 0.0;
                    }
                    ++j;      // Увеличим индекс столбца
                    continue; // Переходим к следующей итерации
                }

                if (l != i)
                {
                    // Меняем местами i-ю и l-ю строки
                    for (k = j; k < n + 1; ++k)
                    {
                        r = a1[i, k];
                        a1[i, k] = a1[l, k];
                        a1[l, k] = (-r); // Меняем знак строки
                    }
                }

                // Обнуляем j-й столбец, начиная со строки i+1,
                // применяя элем. преобразования второго рода
                for (k = i + 1; k < n + 1; ++k)
                {
                    r = (-a1[k, j] / a1[i, j]);

                    // К k-й строке прибавляем i-ю, умноженную на r
                    a1[k, j] = 0.0;
                    for (l = j + 1; l < n + 1; ++l)
                    {
                        a1[k, l] += r * a1[i, l];
                    }
                }
                ++i; ++j;   // Переходим к следующему минору
            }
            Array.Clear(a1, 0, (n + 1) * (n + 1));
            return i; // Возвращаем число ненулевых строк (ранг матрицы) 
        }
    }
}

